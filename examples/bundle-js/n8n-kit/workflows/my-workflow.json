{
	"active": false,
	"connections": {
		"Get data from some API": {
			"main": [[{ "index": 0, "node": "Validate data", "type": "main" }]]
		},
		"When clicking ‘Test workflow’": {
			"main": [
				[{ "index": 0, "node": "Get data from some API", "type": "main" }]
			]
		}
	},
	"id": "ykkWdTItQQHbh",
	"name": "Code Bundle Example",
	"nodes": [
		{
			"id": "Bundle JS",
			"name": "Validate data",
			"parameters": {
				"jsCode": "\n//#region src/data/some-data.json\nvar hello = \"world\";\nvar some_data_default = { hello };\n\n//#endregion\n//#region node_modules/zod/v4/core/core.js\n/** A special constant with type `never` */\nconst NEVER = Object.freeze({ status: \"aborted\" });\nfunction $constructor(name, initializer$1, params) {\n\tfunction init(inst, def) {\n\t\tvar _a;\n\t\tObject.defineProperty(inst, \"_zod\", {\n\t\t\tvalue: inst._zod ?? {},\n\t\t\tenumerable: false\n\t\t});\n\t\t(_a = inst._zod).traits ?? (_a.traits = /* @__PURE__ */ new Set());\n\t\tinst._zod.traits.add(name);\n\t\tinitializer$1(inst, def);\n\t\tfor (const k in _.prototype) if (!(k in inst)) Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });\n\t\tinst._zod.constr = _;\n\t\tinst._zod.def = def;\n\t}\n\tconst Parent = params?.Parent ?? Object;\n\tclass Definition extends Parent {}\n\tObject.defineProperty(Definition, \"name\", { value: name });\n\tfunction _(def) {\n\t\tvar _a;\n\t\tconst inst = params?.Parent ? new Definition() : this;\n\t\tinit(inst, def);\n\t\t(_a = inst._zod).deferred ?? (_a.deferred = []);\n\t\tfor (const fn of inst._zod.deferred) fn();\n\t\treturn inst;\n\t}\n\tObject.defineProperty(_, \"init\", { value: init });\n\tObject.defineProperty(_, Symbol.hasInstance, { value: (inst) => {\n\t\tif (params?.Parent && inst instanceof params.Parent) return true;\n\t\treturn inst?._zod?.traits?.has(name);\n\t} });\n\tObject.defineProperty(_, \"name\", { value: name });\n\treturn _;\n}\nconst $brand = Symbol(\"zod_brand\");\nvar $ZodAsyncError = class extends Error {\n\tconstructor() {\n\t\tsuper(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);\n\t}\n};\nconst globalConfig = {};\nfunction config(newConfig) {\n\tif (newConfig) Object.assign(globalConfig, newConfig);\n\treturn globalConfig;\n}\n\n//#endregion\n//#region node_modules/zod/v4/core/util.js\nfunction getEnumValues(entries) {\n\tconst numericValues = Object.values(entries).filter((v) => typeof v === \"number\");\n\treturn Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);\n}\nfunction jsonStringifyReplacer(_, value) {\n\tif (typeof value === \"bigint\") return value.toString();\n\treturn value;\n}\nfunction cached(getter) {\n\treturn { get value() {\n\t\t{\n\t\t\tconst value = getter();\n\t\t\tObject.defineProperty(this, \"value\", { value });\n\t\t\treturn value;\n\t\t}\n\t\tthrow new Error(\"cached value already set\");\n\t} };\n}\nfunction nullish(input) {\n\treturn input === null || input === void 0;\n}\nconst EVALUATING = Symbol(\"evaluating\");\nfunction defineLazy(object$1, key, getter) {\n\tlet value = void 0;\n\tObject.defineProperty(object$1, key, {\n\t\tget() {\n\t\t\tif (value === EVALUATING) return;\n\t\t\tif (value === void 0) {\n\t\t\t\tvalue = EVALUATING;\n\t\t\t\tvalue = getter();\n\t\t\t}\n\t\t\treturn value;\n\t\t},\n\t\tset(v) {\n\t\t\tObject.defineProperty(object$1, key, { value: v });\n\t\t},\n\t\tconfigurable: true\n\t});\n}\nfunction assignProp(target, prop, value) {\n\tObject.defineProperty(target, prop, {\n\t\tvalue,\n\t\twritable: true,\n\t\tenumerable: true,\n\t\tconfigurable: true\n\t});\n}\nconst captureStackTrace = \"captureStackTrace\" in Error ? Error.captureStackTrace : (..._args) => {};\nfunction isObject(data) {\n\treturn typeof data === \"object\" && data !== null && !Array.isArray(data);\n}\nconst allowsEval = cached(() => {\n\tif (typeof navigator !== \"undefined\" && navigator?.userAgent?.includes(\"Cloudflare\")) return false;\n\ttry {\n\t\tnew Function(\"\");\n\t\treturn true;\n\t} catch (_) {\n\t\treturn false;\n\t}\n});\nconst propertyKeyTypes = new Set([\n\t\"string\",\n\t\"number\",\n\t\"symbol\"\n]);\nfunction escapeRegex(str) {\n\treturn str.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction clone(inst, def, params) {\n\tconst cl = new inst._zod.constr(def ?? inst._zod.def);\n\tif (!def || params?.parent) cl._zod.parent = inst;\n\treturn cl;\n}\nfunction normalizeParams(_params) {\n\tconst params = _params;\n\tif (!params) return {};\n\tif (typeof params === \"string\") return { error: () => params };\n\tif (params?.message !== void 0) {\n\t\tif (params?.error !== void 0) throw new Error(\"Cannot specify both `message` and `error` params\");\n\t\tparams.error = params.message;\n\t}\n\tdelete params.message;\n\tif (typeof params.error === \"string\") return {\n\t\t...params,\n\t\terror: () => params.error\n\t};\n\treturn params;\n}\nfunction optionalKeys(shape) {\n\treturn Object.keys(shape).filter((k) => {\n\t\treturn shape[k]._zod.optin === \"optional\" && shape[k]._zod.optout === \"optional\";\n\t});\n}\nconst NUMBER_FORMAT_RANGES = {\n\tsafeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],\n\tint32: [-2147483648, 2147483647],\n\tuint32: [0, 4294967295],\n\tfloat32: [-34028234663852886e22, 34028234663852886e22],\n\tfloat64: [-Number.MAX_VALUE, Number.MAX_VALUE]\n};\nfunction aborted(x, startIndex = 0) {\n\tif (x.aborted === true) return true;\n\tfor (let i = startIndex; i < x.issues.length; i++) if (x.issues[i]?.continue !== true) return true;\n\treturn false;\n}\nfunction prefixIssues(path, issues) {\n\treturn issues.map((iss) => {\n\t\tvar _a;\n\t\t(_a = iss).path ?? (_a.path = []);\n\t\tiss.path.unshift(path);\n\t\treturn iss;\n\t});\n}\nfunction unwrapMessage(message) {\n\treturn typeof message === \"string\" ? message : message?.message;\n}\nfunction finalizeIssue(iss, ctx, config$1) {\n\tconst full = {\n\t\t...iss,\n\t\tpath: iss.path ?? []\n\t};\n\tif (!iss.message) full.message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config$1.customError?.(iss)) ?? unwrapMessage(config$1.localeError?.(iss)) ?? \"Invalid input\";\n\tdelete full.inst;\n\tdelete full.continue;\n\tif (!ctx?.reportInput) delete full.input;\n\treturn full;\n}\nfunction getLengthableOrigin(input) {\n\tif (Array.isArray(input)) return \"array\";\n\tif (typeof input === \"string\") return \"string\";\n\treturn \"unknown\";\n}\n\n//#endregion\n//#region node_modules/zod/v4/core/errors.js\nconst initializer = (inst, def) => {\n\tinst.name = \"$ZodError\";\n\tObject.defineProperty(inst, \"_zod\", {\n\t\tvalue: inst._zod,\n\t\tenumerable: false\n\t});\n\tObject.defineProperty(inst, \"issues\", {\n\t\tvalue: def,\n\t\tenumerable: false\n\t});\n\tinst.message = JSON.stringify(def, jsonStringifyReplacer, 2);\n\tObject.defineProperty(inst, \"toString\", {\n\t\tvalue: () => inst.message,\n\t\tenumerable: false\n\t});\n};\nconst $ZodError = $constructor(\"$ZodError\", initializer);\nconst $ZodRealError = $constructor(\"$ZodError\", initializer, { Parent: Error });\n\n//#endregion\n//#region node_modules/zod/v4/core/parse.js\nconst _parse = (_Err) => (schema$1, value, _ctx, _params) => {\n\tconst ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };\n\tconst result = schema$1._zod.run({\n\t\tvalue,\n\t\tissues: []\n\t}, ctx);\n\tif (result instanceof Promise) throw new $ZodAsyncError();\n\tif (result.issues.length) {\n\t\tconst e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));\n\t\tcaptureStackTrace(e, _params?.callee);\n\t\tthrow e;\n\t}\n\treturn result.value;\n};\nconst parse = /* @__PURE__ */ _parse($ZodRealError);\nconst _parseAsync = (_Err) => async (schema$1, value, _ctx, params) => {\n\tconst ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };\n\tlet result = schema$1._zod.run({\n\t\tvalue,\n\t\tissues: []\n\t}, ctx);\n\tif (result instanceof Promise) result = await result;\n\tif (result.issues.length) {\n\t\tconst e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));\n\t\tcaptureStackTrace(e, params?.callee);\n\t\tthrow e;\n\t}\n\treturn result.value;\n};\nconst parseAsync = /* @__PURE__ */ _parseAsync($ZodRealError);\nconst _safeParse = (_Err) => (schema$1, value, _ctx) => {\n\tconst ctx = _ctx ? {\n\t\t..._ctx,\n\t\tasync: false\n\t} : { async: false };\n\tconst result = schema$1._zod.run({\n\t\tvalue,\n\t\tissues: []\n\t}, ctx);\n\tif (result instanceof Promise) throw new $ZodAsyncError();\n\treturn result.issues.length ? {\n\t\tsuccess: false,\n\t\terror: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))\n\t} : {\n\t\tsuccess: true,\n\t\tdata: result.value\n\t};\n};\nconst safeParse = /* @__PURE__ */ _safeParse($ZodRealError);\nconst _safeParseAsync = (_Err) => async (schema$1, value, _ctx) => {\n\tconst ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };\n\tlet result = schema$1._zod.run({\n\t\tvalue,\n\t\tissues: []\n\t}, ctx);\n\tif (result instanceof Promise) result = await result;\n\treturn result.issues.length ? {\n\t\tsuccess: false,\n\t\terror: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))\n\t} : {\n\t\tsuccess: true,\n\t\tdata: result.value\n\t};\n};\nconst safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);\nconst _encode = (_Err) => (schema$1, value, _ctx) => {\n\tconst ctx = _ctx ? Object.assign(_ctx, { direction: \"backward\" }) : { direction: \"backward\" };\n\treturn _parse(_Err)(schema$1, value, ctx);\n};\nconst encode = /* @__PURE__ */ _encode($ZodRealError);\nconst _decode = (_Err) => (schema$1, value, _ctx) => {\n\treturn _parse(_Err)(schema$1, value, _ctx);\n};\nconst decode = /* @__PURE__ */ _decode($ZodRealError);\nconst _encodeAsync = (_Err) => async (schema$1, value, _ctx) => {\n\tconst ctx = _ctx ? Object.assign(_ctx, { direction: \"backward\" }) : { direction: \"backward\" };\n\treturn _parseAsync(_Err)(schema$1, value, ctx);\n};\nconst encodeAsync = /* @__PURE__ */ _encodeAsync($ZodRealError);\nconst _decodeAsync = (_Err) => async (schema$1, value, _ctx) => {\n\treturn _parseAsync(_Err)(schema$1, value, _ctx);\n};\nconst decodeAsync = /* @__PURE__ */ _decodeAsync($ZodRealError);\nconst _safeEncode = (_Err) => (schema$1, value, _ctx) => {\n\tconst ctx = _ctx ? Object.assign(_ctx, { direction: \"backward\" }) : { direction: \"backward\" };\n\treturn _safeParse(_Err)(schema$1, value, ctx);\n};\nconst safeEncode = /* @__PURE__ */ _safeEncode($ZodRealError);\nconst _safeDecode = (_Err) => (schema$1, value, _ctx) => {\n\treturn _safeParse(_Err)(schema$1, value, _ctx);\n};\nconst safeDecode = /* @__PURE__ */ _safeDecode($ZodRealError);\nconst _safeEncodeAsync = (_Err) => async (schema$1, value, _ctx) => {\n\tconst ctx = _ctx ? Object.assign(_ctx, { direction: \"backward\" }) : { direction: \"backward\" };\n\treturn _safeParseAsync(_Err)(schema$1, value, ctx);\n};\nconst safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync($ZodRealError);\nconst _safeDecodeAsync = (_Err) => async (schema$1, value, _ctx) => {\n\treturn _safeParseAsync(_Err)(schema$1, value, _ctx);\n};\nconst safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync($ZodRealError);\n\n//#endregion\n//#region node_modules/zod/v4/core/regexes.js\nconst dateSource = `(?:(?:\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\\\d|30)|(?:02)-(?:0[1-9]|1\\\\d|2[0-8])))`;\nconst date = /* @__PURE__ */ new RegExp(`^${dateSource}$`);\nconst string$1 = (params) => {\n\tconst regex = params ? `[\\\\s\\\\S]{${params?.minimum ?? 0},${params?.maximum ?? \"\"}}` : `[\\\\s\\\\S]*`;\n\treturn /* @__PURE__ */ new RegExp(`^${regex}$`);\n};\n\n//#endregion\n//#region node_modules/zod/v4/core/checks.js\nconst $ZodCheck = /* @__PURE__ */ $constructor(\"$ZodCheck\", (inst, def) => {\n\tvar _a;\n\tinst._zod ?? (inst._zod = {});\n\tinst._zod.def = def;\n\t(_a = inst._zod).onattach ?? (_a.onattach = []);\n});\nconst $ZodCheckLengthEquals = /* @__PURE__ */ $constructor(\"$ZodCheckLengthEquals\", (inst, def) => {\n\tvar _a;\n\t$ZodCheck.init(inst, def);\n\t(_a = inst._zod.def).when ?? (_a.when = (payload) => {\n\t\tconst val = payload.value;\n\t\treturn !nullish(val) && val.length !== void 0;\n\t});\n\tinst._zod.onattach.push((inst$1) => {\n\t\tconst bag = inst$1._zod.bag;\n\t\tbag.minimum = def.length;\n\t\tbag.maximum = def.length;\n\t\tbag.length = def.length;\n\t});\n\tinst._zod.check = (payload) => {\n\t\tconst input = payload.value;\n\t\tconst length = input.length;\n\t\tif (length === def.length) return;\n\t\tconst origin = getLengthableOrigin(input);\n\t\tconst tooBig = length > def.length;\n\t\tpayload.issues.push({\n\t\t\torigin,\n\t\t\t...tooBig ? {\n\t\t\t\tcode: \"too_big\",\n\t\t\t\tmaximum: def.length\n\t\t\t} : {\n\t\t\t\tcode: \"too_small\",\n\t\t\t\tminimum: def.length\n\t\t\t},\n\t\t\tinclusive: true,\n\t\t\texact: true,\n\t\t\tinput: payload.value,\n\t\t\tinst,\n\t\t\tcontinue: !def.abort\n\t\t});\n\t};\n});\n\n//#endregion\n//#region node_modules/zod/v4/core/versions.js\nconst version = {\n\tmajor: 4,\n\tminor: 1,\n\tpatch: 5\n};\n\n//#endregion\n//#region node_modules/zod/v4/core/schemas.js\nconst $ZodType = /* @__PURE__ */ $constructor(\"$ZodType\", (inst, def) => {\n\tvar _a;\n\tinst ?? (inst = {});\n\tinst._zod.def = def;\n\tinst._zod.bag = inst._zod.bag || {};\n\tinst._zod.version = version;\n\tconst checks = [...inst._zod.def.checks ?? []];\n\tif (inst._zod.traits.has(\"$ZodCheck\")) checks.unshift(inst);\n\tfor (const ch of checks) for (const fn of ch._zod.onattach) fn(inst);\n\tif (checks.length === 0) {\n\t\t(_a = inst._zod).deferred ?? (_a.deferred = []);\n\t\tinst._zod.deferred?.push(() => {\n\t\t\tinst._zod.run = inst._zod.parse;\n\t\t});\n\t} else {\n\t\tconst runChecks = (payload, checks$1, ctx) => {\n\t\t\tlet isAborted = aborted(payload);\n\t\t\tlet asyncResult;\n\t\t\tfor (const ch of checks$1) {\n\t\t\t\tif (ch._zod.def.when) {\n\t\t\t\t\tif (!ch._zod.def.when(payload)) continue;\n\t\t\t\t} else if (isAborted) continue;\n\t\t\t\tconst currLen = payload.issues.length;\n\t\t\t\tconst _ = ch._zod.check(payload);\n\t\t\t\tif (_ instanceof Promise && ctx?.async === false) throw new $ZodAsyncError();\n\t\t\t\tif (asyncResult || _ instanceof Promise) asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {\n\t\t\t\t\tawait _;\n\t\t\t\t\tif (payload.issues.length === currLen) return;\n\t\t\t\t\tif (!isAborted) isAborted = aborted(payload, currLen);\n\t\t\t\t});\n\t\t\t\telse {\n\t\t\t\t\tif (payload.issues.length === currLen) continue;\n\t\t\t\t\tif (!isAborted) isAborted = aborted(payload, currLen);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (asyncResult) return asyncResult.then(() => {\n\t\t\t\treturn payload;\n\t\t\t});\n\t\t\treturn payload;\n\t\t};\n\t\tconst handleCanaryResult = (canary, payload, ctx) => {\n\t\t\tif (aborted(canary)) {\n\t\t\t\tcanary.aborted = true;\n\t\t\t\treturn canary;\n\t\t\t}\n\t\t\tconst checkResult = runChecks(payload, checks, ctx);\n\t\t\tif (checkResult instanceof Promise) {\n\t\t\t\tif (ctx.async === false) throw new $ZodAsyncError();\n\t\t\t\treturn checkResult.then((checkResult$1) => inst._zod.parse(checkResult$1, ctx));\n\t\t\t}\n\t\t\treturn inst._zod.parse(checkResult, ctx);\n\t\t};\n\t\tinst._zod.run = (payload, ctx) => {\n\t\t\tif (ctx.skipChecks) return inst._zod.parse(payload, ctx);\n\t\t\tif (ctx.direction === \"backward\") {\n\t\t\t\tconst canary = inst._zod.parse({\n\t\t\t\t\tvalue: payload.value,\n\t\t\t\t\tissues: []\n\t\t\t\t}, {\n\t\t\t\t\t...ctx,\n\t\t\t\t\tskipChecks: true\n\t\t\t\t});\n\t\t\t\tif (canary instanceof Promise) return canary.then((canary$1) => {\n\t\t\t\t\treturn handleCanaryResult(canary$1, payload, ctx);\n\t\t\t\t});\n\t\t\t\treturn handleCanaryResult(canary, payload, ctx);\n\t\t\t}\n\t\t\tconst result = inst._zod.parse(payload, ctx);\n\t\t\tif (result instanceof Promise) {\n\t\t\t\tif (ctx.async === false) throw new $ZodAsyncError();\n\t\t\t\treturn result.then((result$1) => runChecks(result$1, checks, ctx));\n\t\t\t}\n\t\t\treturn runChecks(result, checks, ctx);\n\t\t};\n\t}\n\tinst[\"~standard\"] = {\n\t\tvalidate: (value) => {\n\t\t\ttry {\n\t\t\t\tconst r = safeParse(inst, value);\n\t\t\t\treturn r.success ? { value: r.data } : { issues: r.error?.issues };\n\t\t\t} catch (_) {\n\t\t\t\treturn safeParseAsync(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });\n\t\t\t}\n\t\t},\n\t\tvendor: \"zod\",\n\t\tversion: 1\n\t};\n});\nconst $ZodString = /* @__PURE__ */ $constructor(\"$ZodString\", (inst, def) => {\n\t$ZodType.init(inst, def);\n\tinst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string$1(inst._zod.bag);\n\tinst._zod.parse = (payload, _) => {\n\t\tif (def.coerce) try {\n\t\t\tpayload.value = String(payload.value);\n\t\t} catch (_$1) {}\n\t\tif (typeof payload.value === \"string\") return payload;\n\t\tpayload.issues.push({\n\t\t\texpected: \"string\",\n\t\t\tcode: \"invalid_type\",\n\t\t\tinput: payload.value,\n\t\t\tinst\n\t\t});\n\t\treturn payload;\n\t};\n});\nfunction handlePropertyResult(result, final, key, input) {\n\tif (result.issues.length) final.issues.push(...prefixIssues(key, result.issues));\n\tif (result.value === void 0) {\n\t\tif (key in input) final.value[key] = void 0;\n\t} else final.value[key] = result.value;\n}\nfunction normalizeDef(def) {\n\tconst keys = Object.keys(def.shape);\n\tfor (const k of keys) if (!def.shape[k]._zod.traits.has(\"$ZodType\")) throw new Error(`Invalid element at key \"${k}\": expected a Zod schema`);\n\tconst okeys = optionalKeys(def.shape);\n\treturn {\n\t\t...def,\n\t\tkeys,\n\t\tkeySet: new Set(keys),\n\t\tnumKeys: keys.length,\n\t\toptionalKeys: new Set(okeys)\n\t};\n}\nfunction handleCatchall(proms, input, payload, ctx, def, inst) {\n\tconst unrecognized = [];\n\tconst keySet = def.keySet;\n\tconst _catchall = def.catchall._zod;\n\tconst t = _catchall.def.type;\n\tfor (const key of Object.keys(input)) {\n\t\tif (keySet.has(key)) continue;\n\t\tif (t === \"never\") {\n\t\t\tunrecognized.push(key);\n\t\t\tcontinue;\n\t\t}\n\t\tconst r = _catchall.run({\n\t\t\tvalue: input[key],\n\t\t\tissues: []\n\t\t}, ctx);\n\t\tif (r instanceof Promise) proms.push(r.then((r$1) => handlePropertyResult(r$1, payload, key, input)));\n\t\telse handlePropertyResult(r, payload, key, input);\n\t}\n\tif (unrecognized.length) payload.issues.push({\n\t\tcode: \"unrecognized_keys\",\n\t\tkeys: unrecognized,\n\t\tinput,\n\t\tinst\n\t});\n\tif (!proms.length) return payload;\n\treturn Promise.all(proms).then(() => {\n\t\treturn payload;\n\t});\n}\nconst $ZodObject = /* @__PURE__ */ $constructor(\"$ZodObject\", (inst, def) => {\n\t$ZodType.init(inst, def);\n\tconst _normalized = cached(() => normalizeDef(def));\n\tdefineLazy(inst._zod, \"propValues\", () => {\n\t\tconst shape = def.shape;\n\t\tconst propValues = {};\n\t\tfor (const key in shape) {\n\t\t\tconst field = shape[key]._zod;\n\t\t\tif (field.values) {\n\t\t\t\tpropValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());\n\t\t\t\tfor (const v of field.values) propValues[key].add(v);\n\t\t\t}\n\t\t}\n\t\treturn propValues;\n\t});\n\tconst isObject$1 = isObject;\n\tconst catchall = def.catchall;\n\tlet value;\n\tinst._zod.parse = (payload, ctx) => {\n\t\tvalue ?? (value = _normalized.value);\n\t\tconst input = payload.value;\n\t\tif (!isObject$1(input)) {\n\t\t\tpayload.issues.push({\n\t\t\t\texpected: \"object\",\n\t\t\t\tcode: \"invalid_type\",\n\t\t\t\tinput,\n\t\t\t\tinst\n\t\t\t});\n\t\t\treturn payload;\n\t\t}\n\t\tpayload.value = {};\n\t\tconst proms = [];\n\t\tconst shape = value.shape;\n\t\tfor (const key of value.keys) {\n\t\t\tconst r = shape[key]._zod.run({\n\t\t\t\tvalue: input[key],\n\t\t\t\tissues: []\n\t\t\t}, ctx);\n\t\t\tif (r instanceof Promise) proms.push(r.then((r$1) => handlePropertyResult(r$1, payload, key, input)));\n\t\t\telse handlePropertyResult(r, payload, key, input);\n\t\t}\n\t\tif (!catchall) return proms.length ? Promise.all(proms).then(() => payload) : payload;\n\t\treturn handleCatchall(proms, input, payload, ctx, _normalized.value, inst);\n\t};\n});\nconst $ZodEnum = /* @__PURE__ */ $constructor(\"$ZodEnum\", (inst, def) => {\n\t$ZodType.init(inst, def);\n\tconst values = getEnumValues(def.entries);\n\tconst valuesSet = new Set(values);\n\tinst._zod.values = valuesSet;\n\tinst._zod.pattern = /* @__PURE__ */ new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === \"string\" ? escapeRegex(o) : o.toString()).join(\"|\")})$`);\n\tinst._zod.parse = (payload, _ctx) => {\n\t\tconst input = payload.value;\n\t\tif (valuesSet.has(input)) return payload;\n\t\tpayload.issues.push({\n\t\t\tcode: \"invalid_value\",\n\t\t\tvalues,\n\t\t\tinput,\n\t\t\tinst\n\t\t});\n\t\treturn payload;\n\t};\n});\n\n//#endregion\n//#region node_modules/zod/v4/core/api.js\nfunction _string(Class, params) {\n\treturn new Class({\n\t\ttype: \"string\",\n\t\t...normalizeParams(params)\n\t});\n}\nfunction _length(length, params) {\n\treturn new $ZodCheckLengthEquals({\n\t\tcheck: \"length_equals\",\n\t\t...normalizeParams(params),\n\t\tlength\n\t});\n}\n\n//#endregion\n//#region node_modules/zod/v4/mini/schemas.js\nconst ZodMiniType = /* @__PURE__ */ $constructor(\"ZodMiniType\", (inst, def) => {\n\tif (!inst._zod) throw new Error(\"Uninitialized schema in ZodMiniType.\");\n\t$ZodType.init(inst, def);\n\tinst.def = def;\n\tinst.type = def.type;\n\tinst.parse = (data, params) => parse(inst, data, params, { callee: inst.parse });\n\tinst.safeParse = (data, params) => safeParse(inst, data, params);\n\tinst.parseAsync = async (data, params) => parseAsync(inst, data, params, { callee: inst.parseAsync });\n\tinst.safeParseAsync = async (data, params) => safeParseAsync(inst, data, params);\n\tinst.check = (...checks) => {\n\t\treturn inst.clone({\n\t\t\t...def,\n\t\t\tchecks: [...def.checks ?? [], ...checks.map((ch) => typeof ch === \"function\" ? { _zod: {\n\t\t\t\tcheck: ch,\n\t\t\t\tdef: { check: \"custom\" },\n\t\t\t\tonattach: []\n\t\t\t} } : ch)]\n\t\t});\n\t};\n\tinst.clone = (_def, params) => clone(inst, _def, params);\n\tinst.brand = () => inst;\n\tinst.register = ((reg, meta) => {\n\t\treg.add(inst, meta);\n\t\treturn inst;\n\t});\n});\nconst ZodMiniString = /* @__PURE__ */ $constructor(\"ZodMiniString\", (inst, def) => {\n\t$ZodString.init(inst, def);\n\tZodMiniType.init(inst, def);\n});\nfunction string(params) {\n\treturn _string(ZodMiniString, params);\n}\nconst ZodMiniObject = /* @__PURE__ */ $constructor(\"ZodMiniObject\", (inst, def) => {\n\t$ZodObject.init(inst, def);\n\tZodMiniType.init(inst, def);\n\tdefineLazy(inst, \"shape\", () => def.shape);\n});\nfunction object(shape, params) {\n\tconst def = {\n\t\ttype: \"object\",\n\t\tget shape() {\n\t\t\tassignProp(this, \"shape\", { ...shape });\n\t\t\treturn this.shape;\n\t\t},\n\t\t...normalizeParams(params)\n\t};\n\treturn new ZodMiniObject(def);\n}\nconst ZodMiniEnum = /* @__PURE__ */ $constructor(\"ZodMiniEnum\", (inst, def) => {\n\t$ZodEnum.init(inst, def);\n\tZodMiniType.init(inst, def);\n\tinst.options = Object.values(def.entries);\n});\nfunction _enum(values, params) {\n\tconst entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;\n\treturn new ZodMiniEnum({\n\t\ttype: \"enum\",\n\t\tentries,\n\t\t...normalizeParams(params)\n\t});\n}\n\n//#endregion\n//#region src/other-file.ts\nconst schema = object({\n\taction: _enum([\n\t\t\"create\",\n\t\t\"update\",\n\t\t\"delete\"\n\t]),\n\tuser_id: string().check(_length(24))\n});\n\n//#endregion\n//#region src/index.ts\nconst handler = (input) => {\n\tconsole.log(input);\n\tconsole.log(some_data_default);\n\treturn schema.safeParse({\n\t\taction: input.action,\n\t\tuser_id: input.user_id\n\t});\n};\n\n//#endregion\nexports.handler = handler;\nreturn handler({\n  \"action\": $json.action,\n  \"user_id\": $json.user_id,\n  \"some_constant\": \"some-constant\",\n  \"some_object\": $json.some_object,\n  \"custom_expression\": $now,\n  \"same_without_expr\": $now\n});",
				"language": "javaScript",
				"mode": "runOnceForEachItem"
			},
			"position": [460, 60],
			"type": "n8n-nodes-base.code",
			"typeVersion": 2
		},
		{
			"id": "Set some data",
			"name": "Get data from some API",
			"parameters": {
				"assignments": {
					"assignments": [
						{
							"id": "my-workflow/Set some data/0",
							"name": "action",
							"type": "string",
							"value": "create"
						},
						{
							"id": "my-workflow/Set some data/1",
							"name": "user_id",
							"type": "string",
							"value": "invalid-user-id"
						},
						{
							"id": "my-workflow/Set some data/2",
							"name": "some_constant",
							"type": "string",
							"value": "some-constant"
						},
						{
							"id": "my-workflow/Set some data/3",
							"name": "some_object",
							"type": "object",
							"value": { "other_field": 123, "some_field": "some-field" }
						}
					]
				}
			},
			"position": [260, 60],
			"type": "n8n-nodes-base.set",
			"typeVersion": 3.4
		},
		{
			"id": "When clicking ‘Test workflow’",
			"name": "When clicking ‘Test workflow’",
			"position": [60, 60],
			"type": "n8n-nodes-base.manualTrigger",
			"typeVersion": 1
		}
	],
	"settings": {},
	"tags": [{ "name": "@vahor/n8n-ykkWdTItQQHbh" }]
}
